function h(n,r){let t=n.length-r,l=0;do{for(let o=r;o>0;o--)n[l+r]+=n[l],l++;t-=r}while(t>0)}function f(n,r,t){let l=0,o=n.length;const c=o/t;for(;o>r;){for(let e=r;e>0;--e)n[l+r]+=n[l],++l;o-=r}const a=n.slice();for(let e=0;e<c;++e)for(let s=0;s<t;++s)n[t*e+s]=a[(t-s-1)*c+e]}function d(n,r,t,l,o,c){if(!r||r===1)return n;for(let s=0;s<o.length;++s){if(o[s]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(o[s]!==o[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const a=o[0]/8,e=c===2?1:o.length;for(let s=0;s<l&&!(s*e*t*a>=n.byteLength);++s){let i;if(r===2){switch(o[0]){case 8:i=new Uint8Array(n,s*e*t*a,e*t*a);break;case 16:i=new Uint16Array(n,s*e*t*a,e*t*a/2);break;case 32:i=new Uint32Array(n,s*e*t*a,e*t*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${o[0]} bits per sample.`)}h(i,e)}else r===3&&(i=new Uint8Array(n,s*e*t*a,e*t*a),f(i,e,a))}return n}class w{async decode(r,t){const l=await this.decodeBlock(t),o=r.Predictor||1;if(o!==1){const c=!r.StripOffsets,a=c?r.TileWidth:r.ImageWidth,e=c?r.TileLength:r.RowsPerStrip||r.ImageLength;return d(l,o,a,e,r.BitsPerSample,r.PlanarConfiguration)}return l}}export{w};
